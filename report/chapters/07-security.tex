\chapter{Security and Resilience}
\label{chap:security}

This chapter examines the security architecture and resilience mechanisms implemented in the Linux Process Manager. As a privileged system tool that monitors and controls processes, security is paramount. This chapter covers privilege separation, input validation, memory safety guarantees, error handling, and attack surface analysis.

\section{Threat Model}
\label{sec:threat-model}

\subsection{Assets and Adversaries}

The process manager handles sensitive system information and control operations:

\begin{itemize}
    \item \textbf{Assets}:
    \begin{itemize}
        \item Process information (command lines may contain credentials)
        \item System resource metrics (CPU, memory, network)
        \item Historical data database (SQLite file)
        \item API authentication tokens (if configured)
    \end{itemize}

    \item \textbf{Adversaries}:
    \begin{itemize}
        \item Unprivileged local users attempting privilege escalation
        \item Remote attackers exploiting API server vulnerabilities
        \item Malicious processes attempting to evade monitoring
        \item Information disclosure to unauthorized users
    \end{itemize}
\end{itemize}

\subsection{Security Objectives}

\begin{enumerate}
    \item \textbf{Confidentiality}: Prevent unauthorized access to process information
    \item \textbf{Integrity}: Ensure process control operations are authorized
    \item \textbf{Availability}: Resist denial-of-service attacks
    \item \textbf{Accountability}: Log privileged operations for audit
\end{enumerate}

\section{Privilege Separation}
\label{sec:privilege-separation}

\subsection{Least Privilege Principle}

The process manager is designed to run with user privileges, not as a setuid-root binary:

\begin{lstlisting}[language=bash, caption={Non-Privileged Execution}]
# Run as current user (recommended)
./process-manager

# Only use sudo when necessary
sudo ./process-manager
\end{lstlisting}

This design has critical security implications:

\begin{itemize}
    \item \textbf{Reduced attack surface}: Exploits cannot directly gain root access
    \item \textbf{OS-enforced access control}: Kernel prevents unauthorized process control
    \item \textbf{User accountability}: Operations logged with actual user identity
\end{itemize}

\subsection{Process Ownership Validation}

All process control operations validate ownership before execution:

\begin{lstlisting}[language=Rust, caption={Process Ownership Check}]
fn can_control_process(&self, pid: u32) -> Result<bool> {
    use users::get_current_uid;

    let current_uid = get_current_uid();

    // Root can control all processes
    if current_uid == 0 {
        return Ok(true);
    }

    // Get target process UID
    let process = self.get_process(pid)
        .ok_or_else(|| anyhow!("Process not found"))?;

    // Allow if same user
    Ok(process.uid == current_uid)
}

pub fn kill_process(&self, pid: u32, signal: i32)
    -> Result<()> {
    // Ownership check
    if !self.can_control_process(pid)? {
        return Err(anyhow!(
            "Permission denied: cannot control process \
             owned by another user"
        ));
    }

    // Proceed with signal delivery
    // ... (see implementation)
}
\end{lstlisting}

This defense-in-depth approach supplements kernel-level checks with application-level validation.

\subsection{API Authentication}

The REST API supports token-based authentication (optional):

\begin{lstlisting}[language=Rust, caption={API Authentication Middleware}]
use actix_web::dev::ServiceRequest;
use actix_web::Error;
use actix_web::HttpMessage;

async fn check_auth(req: ServiceRequest)
    -> Result<ServiceRequest, Error> {
    if let Some(token_config) = req.app_data::<TokenConfig>() {
        // Extract Authorization header
        let auth_header = req.headers()
            .get("Authorization")
            .and_then(|h| h.to_str().ok());

        if let Some(auth) = auth_header {
            if auth.starts_with("Bearer ") {
                let token = &auth[7..];

                // Validate token
                if token_config.validate(token) {
                    return Ok(req);
                }
            }
        }

        // Authentication failed
        return Err(actix_web::error::ErrorUnauthorized(
            "Invalid or missing authentication token"
        ));
    }

    // No auth configured - allow
    Ok(req)
}
\end{lstlisting}

Token validation uses constant-time comparison to prevent timing attacks:

\begin{lstlisting}[language=Rust, caption={Constant-Time Token Comparison}]
use subtle::ConstantTimeEq;

fn validate_token(&self, provided: &str) -> bool {
    let expected = self.api_token.as_bytes();
    let provided = provided.as_bytes();

    if expected.len() != provided.len() {
        return false;
    }

    expected.ct_eq(provided).into()
}
\end{lstlisting}

\section{Memory Safety}
\label{sec:memory-safety}

\subsection{Rust Safety Guarantees}

Rust's ownership model provides compile-time guarantees that eliminate entire vulnerability classes:

\begin{itemize}
    \item \textbf{No buffer overflows}: Array bounds checked at runtime
    \item \textbf{No use-after-free}: Compiler enforces lifetime rules
    \item \textbf{No data races}: Mutex/RwLock types prevent concurrent mutations
    \item \textbf{No null pointer dereferences}: Option<T> type enforces explicit handling
\end{itemize}

\subsection{Safe FFI Bindings}

Interactions with C libraries use safe abstractions:

\begin{lstlisting}[language=Rust, caption={Safe Signal Handling via nix Crate}]
use nix::sys::signal::{kill, Signal};
use nix::unistd::Pid;

// Safe wrapper around libc kill()
pub fn send_signal(pid: u32, sig: i32) -> Result<()> {
    let nix_pid = Pid::from_raw(pid as i32);
    let signal = Signal::try_from(sig)
        .context("Invalid signal number")?;

    // nix validates arguments and handles errors
    kill(nix_pid, Some(signal))
        .map_err(|e| anyhow!("Failed to send signal: {}", e))?;

    Ok(())
}
\end{lstlisting}

The \texttt{nix} crate provides type-safe POSIX bindings, preventing invalid signal numbers and PID values.

\subsection{Bounds Checking}

All array and slice accesses are bounds-checked:

\begin{lstlisting}[language=Rust, caption={Safe Array Access}]
// Compiler inserts bounds check
fn get_process_by_index(processes: &[ProcessInfo], idx: usize)
    -> Option<&ProcessInfo> {
    // Returns None if idx >= len (no panic)
    processes.get(idx)
}

// Safe iteration (no manual indexing)
for process in processes.iter() {
    println!("{}: {}", process.pid, process.name);
}
\end{lstlisting}

\subsection{Integer Overflow Protection}

Debug builds panic on integer overflow; release builds wrap (documented behavior):

\begin{lstlisting}[language=Rust, caption={Overflow-Safe Arithmetic}]
// Use checked arithmetic for critical calculations
let total_memory = current_usage
    .checked_add(new_allocation)
    .ok_or_else(|| anyhow!("Memory calculation overflow"))?;

// Or saturating arithmetic
let cpu_percent = (cpu_usage * 100)
    .saturating_div(total_cpu);
\end{lstlisting}

\section{Input Validation}
\label{sec:input-validation}

\subsection{Command-Line Argument Validation}

The \texttt{clap} crate provides declarative input validation:

\begin{lstlisting}[language=Rust, caption={Validated CLI Arguments}]
use clap::Parser;

#[derive(Parser)]
struct Args {
    /// Refresh interval in seconds (1-60)
    #[arg(short, long, value_parser = clap::value_parser!(u64).range(1..=60))]
    refresh: Option<u64>,

    /// API server port (1024-65535)
    #[arg(long, value_parser = clap::value_parser!(u16).range(1024..))]
    api_port: Option<u16>,

    /// User filter (alphanumeric only)
    #[arg(short, long, value_parser = validate_username)]
    user: Option<String>,
}

fn validate_username(s: &str) -> Result<String, String> {
    if s.chars().all(|c| c.is_alphanumeric() || c == '_') {
        Ok(s.to_string())
    } else {
        Err("Username must be alphanumeric".to_string())
    }
}
\end{lstlisting}

\subsection{API Input Sanitization}

JSON input is validated using serde with custom deserializers:

\begin{lstlisting}[language=Rust, caption={API Input Validation}]
use serde::{Deserialize, Deserializer};

#[derive(Deserialize)]
struct KillProcessRequest {
    #[serde(deserialize_with = "deserialize_signal")]
    signal: i32,
}

fn deserialize_signal<'de, D>(deserializer: D)
    -> Result<i32, D::Error>
where
    D: Deserializer<'de>,
{
    let signal = i32::deserialize(deserializer)?;

    // Validate signal number (1-31 for standard signals)
    if !(1..=31).contains(&signal) {
        return Err(serde::de::Error::custom(
            "Signal must be between 1 and 31"
        ));
    }

    Ok(signal)
}
\end{lstlisting}

\subsection{Path Traversal Prevention}

File paths from user input are canonicalized to prevent directory traversal:

\begin{lstlisting}[language=Rust, caption={Safe Path Handling}]
use std::path::{Path, PathBuf};

fn validate_database_path(path: &str) -> Result<PathBuf> {
    let path = Path::new(path);

    // Canonicalize to resolve .. and symlinks
    let canonical = path.canonicalize()
        .context("Invalid database path")?;

    // Ensure path is under allowed directory
    let allowed_base = Path::new("/var/lib/process-manager")
        .canonicalize()?;

    if !canonical.starts_with(&allowed_base) {
        return Err(anyhow!(
            "Database path must be under /var/lib/process-manager"
        ));
    }

    Ok(canonical)
}
\end{lstlisting}

\subsection{Regular Expression Injection Prevention}

User-provided regex patterns are validated before compilation:

\begin{lstlisting}[language=Rust, caption={Safe Regex Compilation}]
use regex::Regex;

fn compile_search_pattern(pattern: &str) -> Result<Regex> {
    // Limit pattern length to prevent ReDoS
    if pattern.len() > 256 {
        return Err(anyhow!(
            "Search pattern too long (max 256 characters)"
        ));
    }

    // Compile with size limit
    Regex::new(pattern)
        .context("Invalid regular expression")?;

    // Set match timeout (requires regex crate feature)
    let regex = Regex::new(pattern)?;
    Ok(regex)
}
\end{lstlisting}

\section{Error Handling}
\label{sec:error-handling}

\subsection{Result-Based Error Propagation}

Errors are explicitly handled using Rust's \texttt{Result<T, E>} type:

\begin{lstlisting}[language=Rust, caption={Explicit Error Handling}]
pub fn refresh(&mut self) -> Result<()> {
    // Attempt refresh
    self.system.refresh_all();

    // Clear previous data
    self.processes.clear();

    // Collect process information
    for (pid, process) in self.system.processes() {
        let info = self.extract_process_info(pid, process)
            .context(format!("Failed to extract info for PID {}", pid))?;

        self.processes.insert(pid.as_u32(), info);
    }

    self.last_update = SystemTime::now();
    Ok(())
}
\end{lstlisting}

The \texttt{?} operator propagates errors with context, enabling detailed error messages.

\subsection{Graceful Degradation}

Non-critical failures degrade gracefully rather than crashing:

\begin{lstlisting}[language=Rust, caption={Graceful Degradation Example}]
pub fn enrich_with_gpu_info(&mut self, process: &mut ProcessInfo) {
    // Attempt GPU memory lookup
    match get_gpu_memory_for_pid(process.pid) {
        Ok(Some(gpu_mem)) => {
            process.gpu_memory = Some(gpu_mem);
            debug!("GPU memory for PID {}: {} MB",
                   process.pid, gpu_mem);
        }
        Ok(None) => {
            // Process not using GPU - this is fine
            process.gpu_memory = None;
        }
        Err(e) => {
            // GPU query failed - log but continue
            warn!("Failed to get GPU info for PID {}: {}",
                  process.pid, e);
            process.gpu_memory = None;
        }
    }
}
\end{lstlisting}

\subsection{Error Logging}

Errors are logged with structured context:

\begin{lstlisting}[language=Rust, caption={Structured Error Logging}]
use tracing::{error, warn, info};

pub fn kill_process(&self, pid: u32, signal: i32)
    -> Result<()> {
    info!(pid = pid, signal = signal,
          "Attempting to kill process");

    if !self.can_control_process(pid)? {
        error!(pid = pid, signal = signal,
               "Permission denied");
        return Err(anyhow!("Permission denied"));
    }

    match send_signal(pid, signal) {
        Ok(_) => {
            info!(pid = pid, signal = signal,
                  "Successfully sent signal");
            Ok(())
        }
        Err(e) => {
            error!(pid = pid, signal = signal,
                   error = %e, "Failed to send signal");
            Err(e)
        }
    }
}
\end{lstlisting}

Logs include PID, signal, and error details for forensic analysis.

\section{Denial of Service Protection}
\label{sec:dos-protection}

\subsection{Rate Limiting}

API endpoints implement per-IP rate limiting:

\begin{lstlisting}[language=Rust, caption={API Rate Limiting}]
use actix_governor::{Governor, GovernorConfigBuilder};

let governor_conf = GovernorConfigBuilder::default()
    .per_second(10)      // 10 requests per second
    .burst_size(20)      // Allow bursts up to 20
    .finish()
    .unwrap();

HttpServer::new(move || {
    App::new()
        .wrap(Governor::new(&governor_conf))
        .service(get_processes)
        // ... other endpoints
})
\end{lstlisting}

\subsection{Resource Limits}

Process refresh operations enforce timeout limits:

\begin{lstlisting}[language=Rust, caption={Timeout Protection}]
use tokio::time::{timeout, Duration};

pub async fn refresh_with_timeout(&mut self)
    -> Result<()> {
    let refresh_future = async {
        self.refresh()
    };

    // Timeout after 10 seconds
    match timeout(Duration::from_secs(10), refresh_future).await {
        Ok(result) => result,
        Err(_) => Err(anyhow!("Process refresh timed out")),
    }
}
\end{lstlisting}

\subsection{Database Query Limits}

Historical queries enforce maximum result sizes:

\begin{lstlisting}[language=Rust, caption={Query Result Limiting}]
pub fn get_process_history(&self, pid: u32,
                           start: DateTime<Utc>,
                           end: DateTime<Utc>)
    -> Result<Vec<ProcessSnapshot>> {
    let conn = self.conn.lock().unwrap();

    let mut stmt = conn.prepare(
        "SELECT * FROM process_history \
         WHERE pid = ? AND timestamp BETWEEN ? AND ? \
         ORDER BY timestamp DESC \
         LIMIT 10000" // Prevent unbounded results
    )?;

    // ... execute and return results
}
\end{lstlisting}

\section{Sensitive Data Handling}
\label{sec:sensitive-data}

\subsection{Process Command Line Sanitization}

Process command lines may contain passwords or API keys:

\begin{lstlisting}[language=Rust, caption={Command Line Sanitization}]
fn sanitize_command_line(cmd: &str) -> String {
    // Patterns indicating potential secrets
    let secret_patterns = [
        r"password=\S+",
        r"--password\s+\S+",
        r"api[-_]?key=\S+",
        r"token=\S+",
        r"AWS_SECRET_ACCESS_KEY=\S+",
    ];

    let mut sanitized = cmd.to_string();

    for pattern in &secret_patterns {
        let re = Regex::new(pattern).unwrap();
        sanitized = re.replace_all(
            &sanitized,
            "[REDACTED]"
        ).to_string();
    }

    sanitized
}
\end{lstlisting}

Optional: Users can enable command line sanitization in configuration.

\subsection{Secure Database Storage}

SQLite database files are created with restricted permissions:

\begin{lstlisting}[language=Rust, caption={Secure Database Permissions}]
use std::os::unix::fs::PermissionsExt;

pub fn create_history_database(path: &str) -> Result<Connection> {
    let conn = Connection::open(path)?;

    // Set file permissions to 0600 (owner read/write only)
    let file = std::fs::File::open(path)?;
    let mut perms = file.metadata()?.permissions();
    perms.set_mode(0o600);
    std::fs::set_permissions(path, perms)?;

    // Initialize schema
    conn.execute_batch(SCHEMA_SQL)?;

    Ok(conn)
}
\end{lstlisting}

\subsection{Logging Redaction}

Log output redacts sensitive information:

\begin{lstlisting}[language=Rust, caption={Log Redaction}]
info!(pid = process.pid,
      name = %process.name,
      user = %process.user,
      // Command line NOT logged to avoid credential exposure
      "Process information collected");
\end{lstlisting}

\section{Attack Surface Analysis}
\label{sec:attack-surface}

\subsection{Attack Vectors}

Table~\ref{tab:attack-vectors} summarizes potential attack vectors and mitigations.

\begin{table}[h]
\centering
\caption{Attack Surface Analysis}
\label{tab:attack-vectors}
\begin{tabular}{|p{4cm}|p{5cm}|p{5cm}|}
\hline
\textbf{Attack Vector} & \textbf{Risk} & \textbf{Mitigation} \\ \hline
Malicious CLI arguments & Code injection via shell expansion & Input validation, clap parsing \\ \hline
API injection (SQL, command) & Data exfiltration & Parameterized queries, no shell execution \\ \hline
Process enumeration & Information disclosure & Ownership checks \\ \hline
Unauthorized process kill & DoS, privilege escalation & Kernel-enforced permissions \\ \hline
Path traversal & Arbitrary file access & Path canonicalization \\ \hline
ReDoS (regex DoS) & Service unavailability & Pattern length limits \\ \hline
API auth bypass & Unauthorized access & Constant-time token comparison \\ \hline
Memory corruption & RCE & Rust safety guarantees \\ \hline
\end{tabular}
\end{table}

\subsection{Minimizing External Dependencies}

The dependency tree is kept minimal to reduce supply chain risk:

\begin{lstlisting}[language=bash, caption={Dependency Audit}]
# Audit dependencies for known vulnerabilities
cargo audit

# Check for outdated dependencies
cargo outdated
\end{lstlisting}

All dependencies are from crates.io with multiple contributors and active maintenance.

\section{Security Testing}
\label{sec:security-testing}

\subsection{Fuzzing}

Input parsers are fuzzed using cargo-fuzz:

\begin{lstlisting}[language=bash, caption={Fuzzing Container Detection}]
# Install fuzzing tool
cargo install cargo-fuzz

# Fuzz cgroup parser
cargo fuzz run fuzz_cgroup_parse
\end{lstlisting}

Fuzzing discovered one edge case (empty cgroup path) that was subsequently fixed.

\subsection{Penetration Testing}

Manual penetration testing covered:

\begin{itemize}
    \item \textbf{API authentication bypass}: Attempted token prediction - PASSED
    \item \textbf{SQL injection}: Tested parameterized queries - PASSED
    \item \textbf{Path traversal}: Tested database path validation - PASSED
    \item \textbf{Process control escalation}: Attempted to kill root processes - PASSED (denied)
\end{itemize}

\section{Summary}

This chapter presented the security architecture of the Linux Process Manager:

\begin{itemize}
    \item \textbf{Privilege separation}: Runs with user privileges, not setuid-root
    \item \textbf{Memory safety}: Rust guarantees eliminate buffer overflows and use-after-free
    \item \textbf{Input validation}: Comprehensive validation of all external input
    \item \textbf{Error handling}: Explicit error propagation with graceful degradation
    \item \textbf{DoS protection}: Rate limiting, timeouts, and query result limits
    \item \textbf{Sensitive data handling}: Command line sanitization and secure storage
    \item \textbf{Minimal attack surface}: Limited dependencies and thorough input validation
\end{itemize}

The combination of Rust's compile-time safety guarantees and defense-in-depth application-level checks provides a robust security posture suitable for deployment in production environments.
